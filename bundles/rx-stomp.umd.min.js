!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):"function"==typeof define&&define.amd?define("RxStomp",["rxjs","rxjs/operators","@stomp/stompjs"],t):"object"==typeof exports?exports.RxStomp=t(require("rxjs"),require("rxjs/operators"),require("@stomp/stompjs")):e.RxStomp=t(e.rxjs,e.rxjs.operators,e.StompJs)}("undefined"!=typeof self?self:this,(function(e,t,n){return function(e){var t={};function n(s){if(t[s])return t[s].exports;var r=t[s]={i:s,l:!1,exports:{}};return e[s].call(r.exports,r,r.exports,n),r.l=!0,r.exports}return n.m=e,n.c=t,n.d=function(e,t,s){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:s})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var s=Object.create(null);if(n.r(s),Object.defineProperty(s,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var r in e)n.d(s,r,function(t){return e[t]}.bind(null,r));return s},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=4)}([function(t,n){t.exports=e},function(e,n){e.exports=t},function(e,t){e.exports=n},function(e,t,n){"use strict";var s=function(){function e(){}return e.UUID=function(){if("undefined"!=typeof window&&void 0!==window.crypto&&void 0!==window.crypto.getRandomValues){var e=new Uint16Array(8);return window.crypto.getRandomValues(e),this.pad4(e[0])+this.pad4(e[1])+"-"+this.pad4(e[2])+"-"+this.pad4(e[3])+"-"+this.pad4(e[4])+"-"+this.pad4(e[5])+this.pad4(e[6])+this.pad4(e[7])}return this.random4()+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+"-"+this.random4()+this.random4()+this.random4()},e.pad4=function(e){for(var t=e.toString(16);t.length<4;)t="0"+t;return t},e.random4=function(){return Math.floor(65536*(1+Math.random())).toString(16).substring(1)},e}();t.UUID=s},function(e,t,n){e.exports=n(5)},function(e,t,n){"use strict";n.r(t),n.d(t,"RxStompConfig",(function(){return s})),n.d(t,"RxStomp",(function(){return c})),n.d(t,"RxStompState",(function(){return r})),n.d(t,"RxStompRPCConfig",(function(){return a})),n.d(t,"RxStompRPC",(function(){return h}));class s{}var r,i=n(0),o=n(1),u=n(2);!function(e){e[e.CONNECTING=0]="CONNECTING",e[e.OPEN=1]="OPEN",e[e.CLOSING=2]="CLOSING",e[e.CLOSED=3]="CLOSED"}(r||(r={}));class c{constructor(){this._queuedMessages=[],this._stompClient=new u.Client;const e=()=>{};this._beforeConnect=e,this._debug=e,this._connectionStatePre$=new i.BehaviorSubject(r.CLOSED),this._connectedPre$=this._connectionStatePre$.pipe(Object(o.filter)(e=>e===r.OPEN)),this.connectionState$=new i.BehaviorSubject(r.CLOSED),this.connected$=this.connectionState$.pipe(Object(o.filter)(e=>e===r.OPEN)),this.connected$.subscribe(()=>{this._sendQueuedMessages()}),this._serverHeadersBehaviourSubject$=new i.BehaviorSubject(null),this.serverHeaders$=this._serverHeadersBehaviourSubject$.pipe(Object(o.filter)(e=>null!==e)),this.stompErrors$=new i.Subject,this.unhandledMessage$=new i.Subject,this.unhandledReceipts$=new i.Subject,this.unhandledFrame$=new i.Subject,this.webSocketErrors$=new i.Subject}get stompClient(){return this._stompClient}configure(e){const t=Object.assign({},e);t.beforeConnect&&(this._beforeConnect=t.beforeConnect,delete t.beforeConnect),this._stompClient.configure(t),t.debug&&(this._debug=t.debug)}activate(){this._stompClient.configure({beforeConnect:async()=>{this._changeState(r.CONNECTING),await this._beforeConnect(this)},onConnect:e=>{this._serverHeadersBehaviourSubject$.next(e.headers),this._changeState(r.OPEN)},onStompError:e=>{this.stompErrors$.next(e)},onWebSocketClose:()=>{this._changeState(r.CLOSED)},onUnhandledMessage:e=>{this.unhandledMessage$.next(e)},onUnhandledReceipt:e=>{this.unhandledReceipts$.next(e)},onUnhandledFrame:e=>{this.unhandledFrame$.next(e)},onWebSocketError:e=>{this.webSocketErrors$.next(e)}}),this._stompClient.activate()}async deactivate(){this._changeState(r.CLOSING),await this._stompClient.deactivate(),this._changeState(r.CLOSED)}connected(){return this.connectionState$.getValue()===r.OPEN}get active(){return this.stompClient.active}publish(e){const t=null==e.retryIfDisconnected||e.retryIfDisconnected;if(this.connected())this._stompClient.publish(e);else{if(!t)throw new Error("Cannot publish while broker is not connected");this._debug("Not connected, queueing"),this._queuedMessages.push(e)}}_sendQueuedMessages(){const e=this._queuedMessages;if(this._queuedMessages=[],0!==e.length){this._debug(`Will try sending  ${e.length} queued message(s)`);for(const t of e)this._debug("Attempting to send "+t),this.publish(t)}}watch(e,t={}){const n={subHeaders:{},unsubHeaders:{},subscribeOnlyOnce:!1};let s;s="string"==typeof e?Object.assign({},n,{destination:e,subHeaders:t}):Object.assign({},n,e),this._debug("Request to subscribe "+s.destination);return i.Observable.create(e=>{let t,n,r=this._connectedPre$;return s.subscribeOnlyOnce&&(r=r.pipe(Object(o.take)(1))),n=r.subscribe(()=>{this._debug("Will subscribe to "+s.destination),t=this._stompClient.subscribe(s.destination,t=>{e.next(t)},s.subHeaders)}),()=>{if(this._debug(`Stop watching connection state (for ${s.destination})`),n.unsubscribe(),this.connected()){this._debug(`Will unsubscribe from ${s.destination} at Stomp`);let e=s.unsubHeaders;"function"==typeof e&&(e=e()),t.unsubscribe(e)}else this._debug(`Stomp not connected, no need to unsubscribe from ${s.destination} at Stomp`)}}).pipe(Object(o.share)())}watchForReceipt(e,t){this._stompClient.watchForReceipt(e,t)}_changeState(e){this._connectionStatePre$.next(e),this.connectionState$.next(e)}}class a{}var d=n(3);class h{constructor(e,t){this.rxStomp=e,this.stompRPCConfig=t,this._replyQueueName="/temp-queue/rpc-replies",this._setupReplyQueue=()=>this.rxStomp.unhandledMessage$,t&&(t.replyQueueName&&(this._replyQueueName=t.replyQueueName),t.setupReplyQueue&&(this._setupReplyQueue=t.setupReplyQueue))}rpc(e){return this.stream(e).pipe(Object(o.first)())}stream(e){const t=Object.assign({},e.headers||{}),{destination:n,body:s,binaryBody:r}=e;return this._repliesObservable||(this._repliesObservable=this._setupReplyQueue(this._replyQueueName,this.rxStomp)),i.Observable.create(e=>{let i;const u=t["correlation-id"]||d.UUID.UUID();return i=this._repliesObservable.pipe(Object(o.filter)(e=>e.headers["correlation-id"]===u)).subscribe(t=>{e.next(t)}),t["reply-to"]=this._replyQueueName,t["correlation-id"]=u,this.rxStomp.publish({destination:n,body:s,binaryBody:r,headers:t}),()=>{i.unsubscribe()}})}}}])}));
//# sourceMappingURL=rx-stomp.umd.min.js.map